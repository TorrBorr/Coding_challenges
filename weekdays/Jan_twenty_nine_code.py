# A coloured triangle is created from a row of colours, each of which is red, green or blue.
# Successive rows, each containing one fewer colour than the last, are generated by considering
# the two touching colours in the previous row. If these colours are identical, the same colour
# is used in the new row. If they are different, the missing colour is used in the new row.
# This is continued until the final row, with only a single colour, is generated.


def triangle(row):

	first_row = list(row)

	if len(first_row) < 2:
		return first_row[0]

	previous_row = first_row

	for i in range(len(first_row)-1):
		next_row = []

		for j in range(len(previous_row)-1):
			if previous_row[j] == previous_row[j + 1]:
				next_color = previous_row[j]
			else:
				color_choices = ["R", "G", "B"]
				color_choices.remove(previous_row[j])
				color_choices.remove(previous_row[j + 1])
				next_color = color_choices[0]

			next_row.append(next_color)

		previous_row = list(next_row)

	print(next_row[0])
	return next_row[0]   #One-letter, either R, G, or B





#triangle(['R','R','R'])
triangle('RBRGBRBGGRRRBGBBBGG')
#triangle("RGBG")


## Other answers that are much more elegant than mine.
## I see while + for loops, is that more efficint than an embedded for loop?


COLORS = set("RGB")

def triangle(row):
    while len(row)>1:
        row = ''.join( a if a==b else (COLORS-{a,b}).pop() for a,b in zip(row, row[1:]))
    return row

def triangle(row):
    vector = list(row)
    while len(vector) > 1:
        vector = [((set('RGB') - {a, b}).pop(), a)[a == b] for a, b in zip(vector, vector[1:])]
    return vector[0]


def next_color(color0, color1):
    if color0 == color1:
        return color0
    if (color0 == 'B' and color1 == 'G') or (color1 == 'B' and color0 == 'G'):
        return 'R'
    if (color0 == 'R' and color1 == 'G') or (color1 == 'R' and color0 == 'G'):
        return 'B'
    if (color0 == 'R' and color1 == 'B') or (color1 == 'R' and color0 == 'B'):
        return 'G'

def triangle(row):
    while len(row) > 1:
        row = ''.join([next_color(row[i], e) for i, e in enumerate(row[1:])])
    return row